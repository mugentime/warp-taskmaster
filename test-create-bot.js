import fetch from 'node-fetch';
import readline from 'readline';

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const BASE_URL = 'http://localhost:3001';

// Test configuration
const testConfig = {
    // Bot creation scenarios
    botScenarios: [
        {
            name: 'BTC Short Perp Bot - Small Test',
            id: 'test-btc-short-' + Date.now(),
            symbol: 'BTCUSDT',
            strategyType: 'Short Perp',
            investment: 20, // Small amount for testing
            leverage: 5,
            autoManaged: true
        },
        {
            name: 'ETH Long Perp Bot - Test',
            id: 'test-eth-long-' + Date.now(),
            symbol: 'ETHUSDT',
            strategyType: 'Long Perp',
            investment: 15,
            leverage: 3,
            autoManaged: true
        }
    ],
    
    // Test modes
    dryRun: true, // Set to false for actual bot creation
    autoConvert: true, // Enable automatic asset conversion
    testWalletTransfers: true // Test the wallet transfer system
};

// Colors for console output
const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

function colorLog(color, ...messages) {
    console.log(colors[color], ...messages, colors.reset);
}

function promptQuestion(question) {
    return new Promise((resolve) => {
        rl.question(question, (answer) => {
            resolve(answer.trim());
        });
    });
}

async function testServerConnection() {
    colorLog('blue', '\nüîç Testing server connection...');
    try {
        const response = await fetch(`${BASE_URL}/api/v1/test`);
        const data = await response.json();
        if (data.success) {
            colorLog('green', '‚úÖ Backend server operational');
            return true;
        }
    } catch (error) {
        colorLog('red', '‚ùå Backend server not accessible:', error.message);
        return false;
    }
}

async function getAllWalletBalances(apiKey, apiSecret) {
    colorLog('blue', '\nüìä Analyzing all wallet balances...');
    try {
        const response = await fetch(`${BASE_URL}/api/v1/get-all-wallet-balances`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ apiKey, apiSecret })
        });
        
        const data = await response.json();
        if (data.success) {
            colorLog('green', `‚úÖ Multi-wallet analysis complete`);
            colorLog('cyan', `   üí∞ Total Portfolio: ${data.summary.totalUSDT} USDT across ${data.summary.walletsAnalyzed} wallets`);
            
            // Show wallet distribution
            const dist = data.distribution;
            console.log(`   üü¢ Spot: ${dist.spot.assets} assets, ${dist.spot.usdt} USDT`);
            console.log(`   üî∂ Futures: ${dist.futures.assets} assets, ${dist.futures.usdt} USDT`);
            console.log(`   üü° Margin: ${dist.margin.assets} assets, ${dist.margin.usdt} USDT`);
            console.log(`   üî∏ Isolated: ${dist.isolated.assets} assets, ${dist.isolated.usdt} USDT`);
            
            return data;
        } else {
            colorLog('red', `‚ùå Wallet analysis failed: ${data.message}`);
            return null;
        }
    } catch (error) {
        colorLog('red', '‚ùå Wallet balance fetch failed:', error.message);
        return null;
    }
}

async function testWalletTransferPlanning(apiKey, apiSecret, scenario) {
    colorLog('blue', `\nüîÑ Testing wallet transfer planning for: ${scenario.name}`);
    
    try {
        const response = await fetch(`${BASE_URL}/api/v1/plan-wallet-transfers`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                apiKey,
                apiSecret,
                symbol: scenario.symbol,
                strategyType: scenario.strategyType,
                investment: scenario.investment,
                autoExecute: false // Just planning for now
            })
        });
        
        const data = await response.json();
        if (data.success) {
            const transfers = data.transferPlan;
            colorLog('green', `‚úÖ Transfer planning complete`);
            colorLog('cyan', `   üìã Transfers needed: ${transfers.length}`);
            
            if (transfers.length > 0) {
                colorLog('yellow', '   üîÑ Planned Transfers:');
                transfers.forEach((transfer, index) => {
                    console.log(`      ${index + 1}. ${transfer.amount} ${transfer.asset}: ${transfer.fromWallet} ‚Üí ${transfer.toWallet}`);
                    console.log(`         üìù ${transfer.reason}`);
                });
            } else {
                colorLog('green', '   ‚úÖ No transfers needed - optimal distribution already exists');
            }
            
            return data;
        } else {
            colorLog('red', `‚ùå Transfer planning failed: ${data.message}`);
            return null;
        }
    } catch (error) {
        colorLog('red', '‚ùå Transfer planning error:', error.message);
        return null;
    }
}

async function testBotCreationPreflight(apiKey, apiSecret, scenario) {
    colorLog('blue', `\nü§ñ Testing bot creation preflight: ${scenario.name}`);
    
    try {
        const response = await fetch(`${BASE_URL}/api/v1/preflight-bot`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                apiKey,
                apiSecret,
                symbol: scenario.symbol,
                strategyType: scenario.strategyType,
                investment: scenario.investment,
                autoConvert: testConfig.autoConvert,
                dryRun: true // Always dry run for preflight
            })
        });
        
        const data = await response.json();
        if (data.success) {
            const preflight = data.preflight;
            colorLog('green', '‚úÖ Preflight analysis complete');
            
            // Show transfer analysis
            if (preflight.transfers) {
                const transfers = preflight.transfers;
                colorLog('cyan', '   üîÑ Transfer Analysis:');
                console.log(`      Planned: ${transfers.summary.totalTransfers} transfers`);
                console.log(`      Successful: ${transfers.summary.successfulTransfers}`);
                console.log(`      Failed: ${transfers.summary.failedTransfers}`);
            }
            
            // Show conversion analysis
            if (preflight.requiresConversion) {
                colorLog('yellow', '   üí± Asset Conversion Required:');
                console.log(`      Assets to convert: ${preflight.plan.length}`);
                preflight.plan.forEach(asset => {
                    console.log(`      ‚Ä¢ ${asset.asset}: ${asset.estimatedUsdtValue.toFixed(2)} USDT`);
                });
            } else {
                colorLog('green', '   ‚úÖ No asset conversion needed');
            }
            
            // Show readiness status
            const status = preflight.ok ? 'READY TO CREATE' : 'NEEDS PREPARATION';
            colorLog(preflight.ok ? 'green' : 'yellow', `   üéØ Bot Status: ${status}`);
            
            return data;
        } else {
            colorLog('red', `‚ùå Preflight failed: ${data.message}`);
            return null;
        }
    } catch (error) {
        colorLog('red', '‚ùå Preflight analysis error:', error.message);
        return null;
    }
}

async function testBotCreation(apiKey, apiSecret, scenario) {
    colorLog('blue', `\nüöÄ Testing complete bot creation: ${scenario.name}`);
    
    try {
        const response = await fetch(`${BASE_URL}/api/v1/launch-bot`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                id: scenario.id,
                name: scenario.name,
                symbol: scenario.symbol,
                strategyType: scenario.strategyType,
                investment: scenario.investment,
                leverage: scenario.leverage,
                autoManaged: scenario.autoManaged,
                apiKey,
                apiSecret,
                autoConvert: testConfig.autoConvert,
                dryRun: testConfig.dryRun
            })
        });
        
        const data = await response.json();
        if (data.success) {
            colorLog('green', 'üéâ Bot creation successful!');
            
            const bot = data.bot;
            const preflight = data.preflight;
            
            // Show bot details
            colorLog('cyan', '   ü§ñ Bot Details:');
            console.log(`      ID: ${bot.id}`);
            console.log(`      Symbol: ${bot.symbol}`);
            console.log(`      Strategy: ${bot.strategyType}`);
            console.log(`      Investment: $${bot.investment}`);
            console.log(`      Leverage: ${bot.leverage}x`);
            
            // Show automation summary
            if (preflight.transfers) {
                colorLog('magenta', '   üîÑ Automated Operations:');
                console.log(`      Wallet transfers: ${preflight.transfers.summary.totalTransfers}`);
                console.log(`      Asset conversions: ${preflight.executed ? preflight.executed.length : 0}`);
                
                if (preflight.batchStats) {
                    console.log(`      Total converted: ${preflight.batchStats.totalConverted.toFixed(2)} USDT`);
                }
            }
            
            colorLog('green', '   ‚úÖ All automated asset management completed successfully!');
            return data;
            
        } else {
            colorLog('red', `‚ùå Bot creation failed: ${data.message}`);
            if (data.requiresConversion) {
                colorLog('yellow', '   üí° Asset conversion required but not enabled');
            }
            return null;
        }
    } catch (error) {
        colorLog('red', '‚ùå Bot creation error:', error.message);
        return null;
    }
}

async function runCreateBotTests() {
    console.log('\n' + '='.repeat(60));
    colorLog('bright', 'üöÄ AUTOMATED BOT CREATION SYSTEM TEST');
    console.log('='.repeat(60));
    
    // Test server connection
    if (!(await testServerConnection())) {
        process.exit(1);
    }
    
    // Get API credentials
    const apiKey = await promptQuestion('üîê Enter your Binance API Key: ');
    const apiSecret = await promptQuestion('üîë Enter your Binance API Secret: ');
    
    if (!apiKey || !apiSecret) {
        colorLog('red', '‚ùå API credentials required');
        process.exit(1);
    }
    
    colorLog('green', '\n‚úÖ API credentials provided');
    colorLog('yellow', `‚ö†Ô∏è  Test mode: ${testConfig.dryRun ? 'DRY RUN (Safe)' : 'LIVE TRADING'}`);
    colorLog('yellow', `‚ö†Ô∏è  Auto-convert: ${testConfig.autoConvert ? 'ENABLED' : 'DISABLED'}`);
    
    if (!testConfig.dryRun) {
        const confirm = await promptQuestion('\n‚ö†Ô∏è  WARNING: Live mode! Type "CONFIRM" to proceed: ');
        if (confirm !== 'CONFIRM') {
            colorLog('yellow', 'üõë Test cancelled');
            process.exit(0);
        }
    }
    
    try {
        // Step 1: Analyze all wallet balances
        const walletAnalysis = await getAllWalletBalances(apiKey, apiSecret);
        if (!walletAnalysis) {
            colorLog('red', '‚ùå Cannot proceed without wallet data');
            process.exit(1);
        }
        
        // Step 2: Test each bot creation scenario
        colorLog('blue', '\n' + '='.repeat(50));
        colorLog('blue', 'üß™ TESTING BOT CREATION SCENARIOS');
        colorLog('blue', '='.repeat(50));
        
        for (const scenario of testConfig.botScenarios) {
            colorLog('yellow', `\nüìã Scenario: ${scenario.name}`);
            
            // Test wallet transfer planning
            if (testConfig.testWalletTransfers) {
                await testWalletTransferPlanning(apiKey, apiSecret, scenario);
            }
            
            // Test preflight analysis
            await testBotCreationPreflight(apiKey, apiSecret, scenario);
            
            // Test complete bot creation
            await testBotCreation(apiKey, apiSecret, scenario);
            
            colorLog('blue', '\n' + '-'.repeat(40));
        }
        
        // Final summary
        colorLog('green', '\n' + '='.repeat(60));
        colorLog('green', 'üéâ AUTOMATED BOT CREATION TEST COMPLETED');
        colorLog('green', '='.repeat(60));
        
        colorLog('cyan', 'üìã System Capabilities Tested:');
        colorLog('cyan', '  ‚úÖ Multi-wallet balance analysis');
        colorLog('cyan', '  ‚úÖ Intelligent transfer planning');
        colorLog('cyan', '  ‚úÖ Automated asset conversion');
        colorLog('cyan', '  ‚úÖ Comprehensive preflight checks');
        colorLog('cyan', '  ‚úÖ Complete bot creation workflow');
        
        colorLog('magenta', '\nüöÄ Key Features Demonstrated:');
        colorLog('magenta', '  ‚Ä¢ Automatic wallet-to-wallet transfers');
        colorLog('magenta', '  ‚Ä¢ Smart asset conversion with optimal paths');
        colorLog('magenta', '  ‚Ä¢ Strategy-based fund distribution');
        colorLog('magenta', '  ‚Ä¢ Real-time validation and error handling');
        colorLog('magenta', '  ‚Ä¢ Zero manual intervention required');
        
        if (testConfig.dryRun) {
            colorLog('yellow', '\nüí° This was a safe dry-run test');
            colorLog('yellow', '  Set dryRun: false to create actual bots');
        }
        
    } catch (error) {
        colorLog('red', '\n‚ùå Test suite failed:', error.message);
    } finally {
        rl.close();
    }
}

// Handle Ctrl+C gracefully
process.on('SIGINT', () => {
    colorLog('yellow', '\nüõë Test interrupted by user');
    rl.close();
    process.exit(0);
});

// Start the test
runCreateBotTests().catch(error => {
    colorLog('red', 'üí• Unhandled error:', error.message);
    rl.close();
    process.exit(1);
});
